/*
 * generated by Xtext
 */
package org.ruler.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.ruler.modeller.RuleSet
import org.ruler.preferences.RuleOutputConfigurationProvider

/**
 * Generates code from your model files on save.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ModellerGenerator implements IGenerator {

	/**
	 * Naming
	 */
	@Inject extension IQualifiedNameProvider

	/**
	 * Helper extensions for code generation
	 */
	@Inject extension Utils
	@Inject extension RuleSetTrait
	@Inject extension RuleSetGenerator
	@Inject extension RuleRepositoryInterfaceGenerator

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		resource.addBasePackageTransformation

		val repositories = resource.allContents.filter(RuleSet).toIterable

		// Generate RuleSet for all repositories
		for(rs: repositories) {
			fsa.generateFile(
				rs.fullyQualifiedName.toString("/") + ".php",
				rs.doGenerateRuleSet(resource)
			)

			if(rs.hasActions) {
				fsa.generateFile(
					rs.fullyQualifiedName.toString("/") + "Trait.php",
					RuleOutputConfigurationProvider::GEN_ONCE_OUTPUT,
					rs.doGenerateRuleSetTrait()
				)
			}
		}

		// Common Repository interface for all RuleSet classes
		val fqns = basePackageAsQualifiedName(resource)
		val path = fqns.append(
			RuleRepositoryInterfaceGenerator.interfaceName
		).toString("/") + ".php"

		fsa.generateFile(path, doGenerate(fqns))
	}
}
