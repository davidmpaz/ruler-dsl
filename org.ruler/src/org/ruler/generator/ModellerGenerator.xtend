/*
 * generated by Xtext
 */
package org.ruler.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.ruler.modeller.RuleSet
import org.ruler.preferences.RuleOutputConfigurationProvider
import org.ruler.modeller.impl.PackageDeclarationImpl
import org.ruler.modeller.PackageDeclaration
import org.ruler.services.ModellerGrammarAccess.PackageDeclarationElements
import org.ruler.modeller.ModellerPackage
import org.ruler.modeller.ModellerFactory
import org.ruler.preferences.PropertiesProvider
import org.eclipse.emf.ecore.EObject
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.resources.IFile
import org.ruler.modeller.AbstractElement
import org.eclipse.xtext.naming.QualifiedName

/**
 * Generates code from your model files on save.
 *
 * TODO make a default configuration for [base package] this would be the
 * 		glue between existent PHP code and the generated on. This base package
 * 		will be used as starting point in the file system for file generation.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ModellerGenerator implements IGenerator {

	/**
	 * Naming
	 */
	@Inject extension IQualifiedNameProvider

	/**
	 * Helper extensions for code generation
	 */
	@Inject extension Utils
	@Inject extension RuleSetTrait
	@Inject extension RuleSetGenerator
	@Inject extension PropertiesProvider
	@Inject extension RuleRepositoryInterfaceGenerator

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		resource.addBasePackageTransformation

		val repositories = resource.allContents.filter(RuleSet).toIterable

		//TODO remove this assumption with the base package configuration
		// the QualifiedName instance cab be created from this configuration
		var RuleSet repo = null

		// Generate RuleSet for all repositories
		for(rs: repositories) {
			fsa.generateFile(
				rs.fullyQualifiedName.toString("/") + ".php",
				rs.doGenerateRuleSet()
			)
			fsa.generateFile(
				rs.fullyQualifiedName.toString("/") + "Trait.php",
				RuleOutputConfigurationProvider::GEN_ONCE_OUTPUT,
				rs.doGenerateRuleSetTrait()
			)
			// TODO remove this with base package configuration
			repo = rs
		}

		// common Repository interface for all RuleSet classes
		val path = repo.package.fullyQualifiedName.append(
			RuleRepositoryInterfaceGenerator.interfaceName
		).toString("/") + ".php"
		fsa.generateFile(path, repo.doGenerate())
	}

	def addBasePackageTransformation(Resource resource) {
		val base = getBasePkg(getIProject(resource.allContents.head))
		resource.allContents.filter(PackageDeclaration)
			.forall[pkg |
				pkg.name = base + "." + pkg.name
				return true
			]
	}

	def getIProject(EObject object) {
		val path = object.eResource.URI.toPlatformString(true)
		val file = ResourcesPlugin.workspace?.root?.findMember(path) as IFile
		file?.project
	}
}
