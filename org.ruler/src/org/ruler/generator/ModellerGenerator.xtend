/*
 * generated by Xtext
 */
package org.ruler.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.ruler.modeller.RuleSet
import org.ruler.preferences.RuleOutputConfigurationProvider
import org.ruler.modeller.impl.PackageDeclarationImpl
import org.ruler.modeller.PackageDeclaration
import org.ruler.services.ModellerGrammarAccess.PackageDeclarationElements
import org.ruler.modeller.ModellerPackage
import org.ruler.modeller.ModellerFactory
import org.ruler.preferences.PropertiesProvider
import org.eclipse.emf.ecore.EObject
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.resources.IFile
import org.ruler.modeller.AbstractElement
import org.eclipse.xtext.naming.QualifiedName

/**
 * Generates code from your model files on save.
 *
 * TODO make a default configuration for [base package] this would be the
 * 		glue between existent PHP code and the generated on. This base package
 * 		will be used as starting point in the file system for file generation.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ModellerGenerator implements IGenerator {

	/**
	 * Naming
	 */
	@Inject extension IQualifiedNameProvider

	/**
	 * Helper extensions for code generation
	 */
	@Inject extension Utils
	@Inject extension RuleSetTrait
	@Inject extension RuleSetGenerator
	@Inject extension RuleRepositoryInterfaceGenerator

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		resource.addBasePackageTransformation

		val repositories = resource.allContents.filter(RuleSet).toIterable

		//TODO remove this assumption with the base package configuration
		// the QualifiedName instance cab be created from this configuration
		var RuleSet repo = null

		// Generate RuleSet for all repositories
		for(rs: repositories) {
			fsa.generateFile(
				rs.fullyQualifiedName.toString("/") + ".php",
				rs.doGenerateRuleSet()
			)

			if(rs.hasActions) {
				fsa.generateFile(
					rs.fullyQualifiedName.toString("/") + "Trait.php",
					RuleOutputConfigurationProvider::GEN_ONCE_OUTPUT,
					rs.doGenerateRuleSetTrait()
				)
			}
		}

		// Common Repository interface for all RuleSet classes
		val fqns = basePackageAsQualifiedName(resource)
		val path = fqns.append(
			RuleRepositoryInterfaceGenerator.interfaceName
		).toString("/") + ".php"

		fsa.generateFile(path, doGenerate(fqns))
	}
}
